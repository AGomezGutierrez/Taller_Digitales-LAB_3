`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
package pkg_global;

    parameter int N = 6;
    parameter int BITS_WIDTH = 32;
    typedef logic [BITS_WIDTH - 1: 0] bits_width;
    typedef logic [N: 0] bits_n;
    typedef logic [N: 0] bits_n1;
    typedef logic [9 : 0] bitsh_t;
    typedef logic [1023 : 0] [BITS_WIDTH - 1 : 0] matriz_2alaN_x_W_t;
    
    typedef struct packed {
        logic [5:0] not_used1;
        logic [9:0] n_rx_end;
        logic [2:0] not_used2;
        logic [8:0] n_tx_end;
        logic all_0s;
        logic all_1s;
        logic cs_ctrl;
        logic send;
    } struct_reg_control;

endpackage

module top_tactico(
    
    input   logic               clk_100Mhz_pi,
                                rst_pi,
                                miso_pi,
                                btn_send_pi,
                                sw_we_pi,//habilita el WE
                                reg_sel_pi,//controla los demux salida y we
                    [1 : 0]     sw_addr_in_pi,//selecciona la direcccion
                    [10 : 0]    sw_entrada_pi,                    
    output logic                mosi_po,
                                locked_po,
                                cs_ctrl_po,
                    [6 : 0]     display_po,
                    [7 : 0]     display_select_po                     
    );
    
    parameter   time   PERIODO      = 1e-3,
                   PERIODO_send = 1;
    
    import pkg_global::*;
    
    bits_width      salida;       
    
    logic           clk, 
                    send_pulso;
    
        //generar clock 10M
    WCLK generate_clock_10Mhz(
        // Clock out ports
        .CLK_10MHZ              (clk),                  // output CLK_10MHZ
        // Status and control signals
        .locked                 (locked_po),            // output locked
       // Clock in ports
        .CLK_100MHZ             (clk_100Mhz_pi)         // input CLK_100MHZ
    ); 
    
    module_debounce_timer #(.PERIODO(PERIODO_send)) envio_pulso_send (

        .clk_10Mhz_i            (clk),
        .reset_i                (rst_pi),
        .btn_send_i             (btn_send_pi),
        .send_pulso_i           (send_pulso) 
    
    );

    top_interface_spi interface_spi(

        .clk_i                 (clk),
        .rst_i                 (rst_pi),
        .miso_i                (miso_pi),
        .btn_send_i            (send_pulso),
        .sw_we_i               (sw_we_pi),
        .reg_sel_i             (reg_sel_pi),
        .sw_addr_in_i          (sw_addr_in_pi),
        .sw_entrada_i          (sw_entrada_pi),                   
        .mosi_o                (mosi_po),
        .salida_o              (salida),
        .cs_ctrl_o             (cs_ctrl_po)
                           
    );
    
     module_seg7_control #(.PERIODO(PERIODO)) seg7_control(
    
        .clk_10Mhz_i            (clk),
        .reset_i                (rst_pi),
        .display_i              (salida),
        .display_o              (display_po),
        .display_select_o       (display_select_po)
    
    );
    
endmodule



module top_interface_spi(

    input   logic               clk_i,
                                rst_i,
                                miso_i,
                                btn_send_i,
                                sw_we_i,
                                reg_sel_i,
    pkg_global::bits_n          sw_addr_in_i,
                     [10 : 0]   sw_entrada_i,                   
    output logic       [7 : 0]         dato_recibido, 
    output logic                mosi_o,
                                cs_ctrl_o,
                                
                                clk_sim,
                                proccess_o,
                                sck_o,
    pkg_global::bits_width      salida_o                    
);   
    
    
    //IMPORTAR DATOS
    import pkg_global::*;
     
    //variables internas
    logic                       clk,
                                we_rx, 
                                proccess,
                                hold_ctrl,
                                we_ram2;
     

     
    logic       [9 : 0]         rx_o;   
    
    logic                       we_ex1,
                                we_ex2;
    
    bits_n                      addr1,
                                addr2;                          
    
    struct_reg_control          cntr_str;
    
    logic [31 : 0]              dato_ram;
    
    assign clk = clk_i;
    
    //demux we
    module_mux_we mux_we(
        .we_i                   (sw_we_i),
        .reg_sel_i              (reg_sel_i),
        .wr1_o                  (we_ex1),
        .wr2_o                  (we_ex2)       
    );
    
    
    //master spi
    top_master_race_spi master_race_spi(

        .clk_i                  (clk),
        .rst_i                  (rst_i),
        .miso_i                 (miso_i),                     
        .dato_in                (dato_ram),
        .clk_fn                 (clk_sim),
        .cntr_str_i             (cntr_str),  
        .mosi_o                 (mosi_o),
        .we_rx_o                (we_rx),
        .proccess_o             (proccess),
        .hold_ctrl_o            (hold_ctrl),
        .we_ram2_o              (we_ram2),      
        .dato_recibido_r        (dato_recibido),
        .rx_o                   (rx_o),
        .addr2_o                (addr2),
        .cs_ctrl_o              (cs_ctrl_o),
        .sck_o                  (sck_o)
        
    ); 
    
     module_reg_control registro_control(

        .clk_i                  (clk),
        .rst_i                  (rst_i),
        .send_i                 (btn_send_i),
        .proccess_i             (proccess),
        .we_rx_i                (we_rx),
        .we_ex_i                (we_ex1),
        .in_rx_i                (rx_o),
        .in_ex_i                (sw_entrada_i),
        .cntr_str_o             (cntr_str)   
    
    );
    
    module_reg_datos memoria_ram(
        .clk_i                  (clk),
        .rst_i                  (rst_i),  
        .hold_ctrl_i            (hold_ctrl),  
        .addr1_i                (sw_addr_in_i),
        .addr2_i                (addr2),
        .in1_i                  (sw_entrada_i),
        .in2_i                  (dato_recibido),
        .wr1_i                  (we_ex2),
        .wr2_i                  (we_ram2),
        .data_o                 (dato_ram)
    );
    
    module_mux_salida mux_salida(
        .selec_salida_i         (reg_sel_i),
        .salida_datos_o         (dato_ram),
        .salidas_control_o      (cntr_str),
        .salida_i               (salida_o)            
    );

    assign proccess_o = proccess;
    
endmodule
module top_master_race_spi(

    input   logic                       clk_i,
                                        rst_i,
                                        miso_i,                                            
                    [7 : 0]             dato_in,
    pkg_global:: struct_reg_control     cntr_str_i,
     
    output logic                        mosi_o,
                                        we_rx_o,                                      
                                        proccess_o,
                                        hold_ctrl_o,
                                        we_ram2_o,
                                        cs_ctrl_o,
                                        clk_fn,
                                        sck_o,      
                    [7 : 0]             dato_recibido_r,
                    [9 : 0]             rx_o,
    pkg_global::bits_n                  addr2_o
                    
    );   
    
    import pkg_global::*;
    
    //variables internas
    
    logic           [1 : 0]     all;
    
    logic           [2 : 0]     control;
    
    logic                       clk,
                                clk_fp,
                          //      clk_fn,
                                contador,
                                send,
                                progress,
                                we_reg; 
    assign clk = clk_i;
        
    //clock divider
    module_clk_divider_spi clk_divider_spi(

        .clk_i                  (clk),
        .rst_i                  (rst_i),
        .start_i                (hold_ctrl_o),
        .clk_fp_o               (clk_fp),
        .clk_fn_o               (clk_fn),
        .clk_sck_o              (sck_o)
    );   
      
    
    //maquina de estados
    module_state_machine_spi state_machine(
        .clk_i                  (clk),
        .rst_i                  (rst_i),
        .send_i                 (send),
        .progress_i             (progress),
        .contador_i             (contador),
        .control_o              (control)
    );
    
    //Control
    module_control_spi control_spi(
        .clk_i                  (clk),
        .rst_i                  (rst_i),
        .clk_fn_i               (clk_fn),
        .control_i              (control),
        .cntr_str_i             (cntr_str_i),
        .send_o                 (send),
        .we_reg_o               (we_reg),
        .progress_o             (progress),
        .contador_o             (contador),
        .we_rx_o                (we_rx_o),
        .hold_ctrl_o            (hold_ctrl_o),
        .we_ram2_o              (we_ram2_o),
        .all_o                  (all),
        .rx_o                   (rx_o),
        .addr2_o                (addr2_o),
        .cs_ctrl_o              (cs_ctrl_o)   
    );
    
    //MOSI
    module_reg_mosi reg_mosi(
        .clk_i                  (clk),
        .rst_i                  (rst_i),
        .we_i                   (we_reg),
        .clk_fp_i               (clk_fp),
        .all_i                  (all),
        .dato_in_i              (dato_in),
        .mosi_o                 (mosi_o)   
    );
    
    //MISO
    module_reg_miso reg_miso(
        .clk_i                  (clk),
        .rst_i                  (rst_i),
        .clk_fn_i               (clk_fn),
        .miso_i                 (miso_i),
        .dato_recibido_o        (dato_recibido_r)                                       
    );
    
    
    //salidas
    assign proccess_o = progress;
    
    
    
endmodule
module module_state_machine_spi(

        input  logic                    clk_i,
                                        rst_i,
                                        send_i,
                                        progress_i,
                                        contador_i,
        output logic    [2 : 0]         control_o
    );
    
    //PARAMETROS
    parameter   WAIT_SEND               = 2'b00,
                LOAD                    = 2'b01,
                TRANSMISSION            = 2'b10,
                DOWNLOAD                = 2'b11,
                
                //datos control
                CTR_SEND                = 3'b000,
                CTR_PRELOAD1            = 3'b001, 
                CTR_LOAD                = 3'b010,
                CTR_TRANSFER            = 3'b011,               
                CTR_CHECK               = 3'b100,
                CTR_PRELOAD2            = 3'b101, 
                CTR_DOWN                = 3'b110;           
     
    //VARIABLES INTERNAS
    logic       [2 : 0]                 control;
    
    logic                               progress,
                                        send,
                                        contador;
    
    //ASIGNACIONES
    always_comb begin
        send        = send_i;
        progress    = progress_i;
        contador    = contador_i;         
    end
    
    //DECLARACION DE ESTADOS
    logic [1 : 0]                       state,
                                        next_state;

   //MEMORIA              
    always_ff @ ( posedge clk_i ) begin
        if( rst_i ) 
            state <= WAIT_SEND;
        else        
            state <= next_state;
    end 
    
    //MAQUINA DE ESTADOS
    always_comb begin
    
        //reinicio de variables
        control     = '0;
        
        case ( state )
        
            WAIT_SEND : //0
                begin
                    if(!send) begin
                        control             = CTR_SEND;//espera send
                        next_state          = WAIT_SEND;
                    end else begin
                        control             = CTR_PRELOAD1;//envia direccion para cargar datos
                        next_state          = LOAD;
                    end
                end
            
            LOAD : //1
                begin
                    control                 = CTR_LOAD;//carga datos al registro
                    next_state              = TRANSMISSION;
                end
           
            TRANSMISSION : //2
                begin
                    if (!contador) begin
                        control             = CTR_TRANSFER;//proceso de transmision
                        next_state          = state;
                    end else begin
                        control             = CTR_CHECK;//revisa para mas transmisiones
                        next_state          = DOWNLOAD;                       
                    end
                end
            
            DOWNLOAD : begin//3
                    
                if (!progress) begin
                    control                 = CTR_PRELOAD2;//envia direccion para cargar datoss
                    next_state              = LOAD;
                end else begin
                    control                 = CTR_DOWN;//cierra el chinamo y el proceso de transmision
                    next_state              = WAIT_SEND;
                end
            end
            
        endcase
        
    end
    
    //SALIDA DE LA MAQUINA
    assign control_o    = control;
    
endmodule
module module_reg_mosi(
    input   logic                           clk_i,
                                            rst_i,
                                            we_i,
                                            clk_fp_i,
                        [1 : 0]             all_i,
                        [7 : 0]             dato_in_i,
    
    output  logic                           mosi_o
    
    );
    
    //variables internas
    logic  [7 : 0]                          reg_shift_mosi,
                                            dato_in;
                                            
    logic                                   mosi,
                                            clk_fp,
                                            we;
    //asignaturas
    
    assign clk_fp                           = clk_fp_i;
    assign we                               = we_i;
    
    always_comb begin
    
        case(all_i)
        
            2'b00: dato_in = dato_in_i;
            2'b01: dato_in = 8'b1111_1111;
            2'b10: dato_in = 8'b0000_0000;
            2'b11: dato_in = 8'b1111_1111;
            default: dato_in = dato_in_i;
        
        endcase      
         
    end
    
    always @(posedge clk_i) begin
    
        if(rst_i) begin
            mosi            <= 0;
            reg_shift_mosi  <= 0;
            
        end else begin
            if(we) begin
               
               reg_shift_mosi   <= dato_in;  
            
            end else begin
            
               if(clk_fp) begin
                    mosi             <= reg_shift_mosi[7];
                    reg_shift_mosi   <= {reg_shift_mosi[6 : 0], 1'b0 };  
               end
                    
            end
        end
    end
    
    //salidas
    assign mosi_o = mosi;

endmodule
module module_reg_miso(
    input   logic                           clk_i,
                                            rst_i,
                                            clk_fn_i,
                                            miso_i,
    output  logic           [7 : 0]         dato_recibido_o
                                            
    );
    
    //variables internas
    logic  [7 : 0]                          reg_shift_miso;
    logic                                   miso;
    logic                                   clk_fn;
    
    
    
    
    //asignaturas
    
    assign clk_fn                           = clk_fn_i;
    assign miso                             = miso_i;
    
    always @(posedge clk_i) begin
    
        if(rst_i) begin   
            reg_shift_miso <= 0;
        end else begin
        
           if(clk_fn) begin
                reg_shift_miso             <= {reg_shift_miso [6 : 0], miso};  
            end

        end
    
    end
    
    //salidas
    assign dato_recibido_o = reg_shift_miso;

endmodule
module module_reg_datos(
    input  logic                        clk_i,  
    input  logic                        rst_i, 
    input  logic                        hold_ctrl_i,
    input  pkg_global::bits_n           addr1_i,//temporal
    input  pkg_global::bits_n           addr2_i,
    input  [10 : 0]                     in1_i,
    input  [7 : 0]                      in2_i,
    input  logic                        wr1_i,
    input  logic                        wr2_i,
    output pkg_global::bits_width       data_o
    );
    //IMPORTAR DATOS
    import pkg_global::*;
    
    logic [9 : 0]                       addr_ram;
    logic [7 : 0]                       datain_ram;
    logic                               enable_ram;
    logic [7 : 0]                       data_out;   
    
    always_comb begin
        if( hold_ctrl_i ) begin
            if( wr2_i ) begin
                    enable_ram        = 1;
                    addr_ram          = addr2_i;
                    datain_ram        = in2_i[ 7 : 0 ];        
            end
            else begin
                    enable_ram        = 0;
                    addr_ram          = addr2_i;
                    datain_ram        = in2_i[ 7 : 0 ]; 
            end         
        end
        else begin
            if( wr1_i ) begin
                    enable_ram        = 1;
                    addr_ram          = addr1_i;
                    datain_ram        = in1_i[ 7 : 0 ];   
                end
                else begin
                    enable_ram        = 0;
                    addr_ram          = addr1_i;
                    datain_ram        = in1_i[ 7 : 0 ];  
                end
        end
    end
    
    
    module_memoria memoria_1(                
                        .clk_i          (clk_i),
                        .rst_i          (rst_i),
                        .we_i           (enable_ram),
                        .addr_rs1_i     (addr_ram),
                        .addr_rd_i      (addr_ram),
                        .data_in_i      (datain_ram),
                        .rs1_o          (data_out)
    );
    
    assign data_o = {24'b0, data_out};
    
endmodule
module module_reg_control(

    input   logic                               clk_i,
                                                rst_i,
                                                send_i,
                                                proccess_i,
                                                we_rx_i,
                                                we_ex_i,
                     [9 : 0]                    in_rx_i,
                     [10 : 0]                   in_ex_i,
    output  pkg_global:: struct_reg_control     cntr_str_o   
    
    );
        
    logic [31 : 0]  state;
    logic [31 : 0]  next_state;
   
    //generar memoria
    always_ff @(posedge clk_i) begin   
        if(rst_i) state <= 0;
        else      state <= next_state;
    end 
    
    //SIGUIENTE ESTADO
    always@(*) begin
        
        if(send_i && !state[0]) begin
                    
            next_state = {state[31 : 2], 2'b11};
            
        end else begin

            if(state[0]) begin
                
                if(!proccess_i) begin
                
                    if(we_rx_i)
                        next_state   = {state[31 : 26], in_rx_i, state[15 : 0]};
                    else
                        next_state   = state;   
                
                end else 
                    next_state = {state[31 : 26], 10'b0, state[15 : 2], 2'b00}; 
                
            end else begin  
                
                if(we_ex_i) begin
                    next_state = {19'b0, in_ex_i, 2'b00};
                end else begin
                    next_state = state;
                end
                
            end  
     
        end
               
    end
    
    //SALIDA
    always@(*) begin
	   cntr_str_o = state;
    end  
    
endmodule
module module_mux_we (
    input logic         we_i,
                        reg_sel_i,
    output  logic       wr1_o,
                        wr2_o
        
);

    always@(*) begin
    
        case(reg_sel_i)
        
            0: 
                begin
                    wr1_o = we_i;
                    wr2_o = 0;
                end
            
            1:  
                begin
                    wr1_o = 0;
                    wr2_o = we_i;
                end
            
        endcase

    end

endmodule
module module_mux_salida(
    input   logic                       selec_salida_i,
    input   logic   [31 : 0]            salida_datos_o,
                                        salidas_control_o,
    output  logic   [31 : 0]            salida_i            
    );
    
    always@(*) begin
    
        case(selec_salida_i)
        
            0: salida_i = salidas_control_o;
            
            1: salida_i = salida_datos_o;
            
        endcase

    end
endmodule
module module_memoria(
    input   logic                           clk_i,
    input   logic                           rst_i,
    input   logic                           we_i,
    input  pkg_global:: bitsh_t             addr_rs1_i,
    input  pkg_global:: bitsh_t             addr_rd_i,
    input  pkg_global:: bits_width          data_in_i,
    output pkg_global:: bits_width          rs1_o
                     );
    
    import                 pkg_global::*;
    
    
    matriz_2alaN_x_W_t            memoria;
    
    always @ ( posedge clk_i ) begin
     if   ( rst_i )  memoria <=          '0;
     else begin 
            if ( we_i ) begin
                memoria [ addr_rd_i ] <= data_in_i; 
            end
     end
    end
    
    //Logica de salida
    always_comb begin
        rs1_o = memoria [ addr_rs1_i ];
    end
endmodule
module module_debounce_timer #(parameter real PERIODO = 1)(

    input   logic   clk_10Mhz_i,
                    reset_i,
                    btn_send_i,
    output  logic   send_pulso_i 
    
    );
    
    //CLOCK DIVIDER DE PULSO
    
    //variables internas 
   
    int                 divider;   
    real                frecuencia;
    
    logic   [31 : 0]    counter;
    
    logic               start,
                        send,
                        send_pulso;
    
    //asignacion de la frecuencia a dividir
    always_comb begin
    
        frecuencia  = 1.0 / PERIODO ;
        divider     = 10e6 / frecuencia;
        
    end
    
    //logica contador
    always_ff @(posedge clk_10Mhz_i)
        
        if(reset_i) begin
            counter <= 0;
            send    <= 0;
            start   <= 0;      
        end else begin
            if(btn_send_i && !start) begin 
                start   <= 1;
                send    <= 1;
            end         
            if(start) begin //si se habilita inicia el conteo
                if(counter  == (divider - 1)) begin //esto genera un flanco reloj, que se va a dar justo en el counter
                    counter <= 0;
                    start   <= 0;           
                end else begin
                    counter <= counter + 1;
                    send    <= 0;
                end 
            end
        end   
    assign send_pulso_i = send;
    
endmodule
module module_control_spi(

    input  logic                        clk_i,
                                        rst_i,
                                        clk_fn_i,
                        [2 : 0]         control_i,
    pkg_global:: struct_reg_control     cntr_str_i,
       
    output logic                        send_o,
                                        we_reg_o,
                                        progress_o,
                                        contador_o,
                                        we_rx_o,
                                        hold_ctrl_o,
                                        we_ram2_o,
                                        cs_ctrl_o,
                       [1 : 0]          all_o,
                       [9 : 0]          rx_o,
    pkg_global::bits_n                  addr2_o   
    );

     //IMPORTAR DATOS
    import pkg_global::*;
    
                //datos control
    parameter   CTR_SEND                = 3'b000,
                CTR_PRELOAD1            = 3'b001, 
                CTR_LOAD                = 3'b010,
                CTR_TRANSFER            = 3'b011,               
                CTR_CHECK               = 3'b100,
                CTR_PRELOAD2            = 3'b101, 
                CTR_DOWN                = 3'b110; 

    //VARIABLES IMPORTADAS
    bits_n1                             n_rx_end,
                                        rx;
    bits_n                              n_tx_end,
                                        addr2;  
    logic                               all_1s,
                                        all_0s,
                                        send;
    
    logic   [3 : 0]                     contador,
                                        control;                                
    
    logic                               hold_ctrl,
                                        clk_fn,
                                        we_reg,
                                        progress,
                                        en_conta,
                                        we_rx,
                                        we_ram2,
                                        cs_ctrl;


    //ASIGNACIONES INCIALEs
    
    //struct
    assign send                            = cntr_str_i.send;
    assign n_rx_end                        = cntr_str_i.n_rx_end;
    assign n_tx_end                        = cntr_str_i.n_tx_end;
    assign all_1s                          = cntr_str_i.all_1s;
    assign all_0s                          = cntr_str_i.all_0s;
    assign cs_ctrl                         = cntr_str_i.cs_ctrl;
    
    always @(*) begin
   
        //internas del modulo
        control                             = control_i;
        clk_fn                              = clk_fn_i;
      
    end
    
    always @(posedge clk_i) begin
        
        if(rst_i) begin
        
             hold_ctrl           <= 0; 
             addr2               <= 0;
             contador            <= 0;
             we_reg              <= 0;
             progress            <= 0;
             en_conta            <= 0;
             we_rx               <= 0;
             rx                  <= 0; 
             
        end else begin

            case(control)
            
                CTR_SEND: //0
                    begin        
                        hold_ctrl           <= 0;
                        we_ram2             <= 0;  
                    end
                
                CTR_PRELOAD1: //1
                    begin            
                        hold_ctrl           <= 1; 
                        addr2               <= 0;                                     
                    end
                        
                CTR_LOAD: //2
                    begin
                        contador            <= 0;             
                        we_reg              <= 1;
                        we_ram2             <= 0; 
                        
                    end
                       
                CTR_TRANSFER: //3
                    begin             
                         
                        we_reg              <= 0;
                        we_ram2             <= 1;
                        if(contador  != 8) begin
                            if(clk_fn) begin
                                contador <= contador + 1;
                                en_conta <= 0;
                            end
                        end else
                            en_conta <=1;
                            
                    end
                
                CTR_CHECK: //4
                    begin 
                        en_conta                <= 0;
                        we_ram2                 <= 0;      
                        if(n_rx_end < n_tx_end) begin
                            progress            <= 0;
                            addr2               <= addr2 + 1;
                            rx                  <= rx + 1;
                            we_rx               <= 1;
                        end else begin
                            progress            <= 1;
                        end
                    end
    
                CTR_PRELOAD2: //5
                    begin
                       we_reg                   <= 1;
                       we_rx                    <= 0; 
                    end
                   
                CTR_DOWN: //6
                    begin
                        progress                <= 0;
                        rx                      <= 0;
                        we_reg                  <= 0;
                        hold_ctrl               <= 0; 
                    end
                
                default: 
                    begin
                        hold_ctrl               <= 0; 
                        addr2                   <= 0;
                        contador                <= 0;
                        we_reg                  <= 0;
                        progress                <= 0;
                    end
            endcase    
        
        end

    end//end always
    
    //SALIDA
    always_comb begin
        send_o                      = send;
        contador_o                  = en_conta;
        all_o                       = {all_0s, all_1s};
        we_reg_o                    = we_reg;
        progress_o                  = progress;    
        rx_o                        = rx;
        we_rx_o                     = we_rx;
        hold_ctrl_o                 = hold_ctrl;
        addr2_o                     = addr2;
        we_ram2_o                   = we_ram2;
        cs_ctrl_o                   = ~cs_ctrl;
    end
    
endmodule  
module module_clk_divider_spi(

    input   logic       clk_i,
                        rst_i,
                        start_i,
    output  logic       clk_fp_o,
                        clk_fn_o,
                        clk_sck_o
    );   
        
    //variables internas 
    int                 divider;   
    
    logic   [31 : 0]    counter,
                        cntr_flankp,
                        cntr_flankn;
    
    logic               clk_out = 1,
                        clk_fp,
                        clk_fn,
                        flanco = 1;
    
    assign divider      = 100;

    //logica contador
    always_ff @(posedge clk_i)
        
        if(rst_i) begin
        
            counter         <= 0;
            clk_out         <= 1;  
            cntr_flankp     <= 0;
            cntr_flankn     <= 0;
            clk_fp          <= 0; 
            clk_fn          <= 0;
            flanco          <= 1;
            
        end else begin
            
            if(start_i) begin
                
                //CLOCK CON CICLOS DE 50%
                if(counter  == (divider / 2)- 1) begin //esto genera un flanco reloj, que se va a dar justo en el counter         
                    
                    counter             <= 0;
                    clk_out             <= ~clk_out;
               
                end else begin
                        
                    counter             <= counter + 1;
                    
                end
                
                //FLANCOS POSITVOS Y NEGATIVOS AL 50% DEL RELOJ
                if(clk_out) begin
                
                    if(flanco) begin
                        if(cntr_flankp == (divider / 4) - 1) begin                 
                            clk_fp                  <= 1; 
                            cntr_flankp             <= 0;
                            flanco                  <= 0;         
                        end else begin
                            clk_fp                  <= 0;
                            cntr_flankp             <= cntr_flankp + 1;
                        end              
                    end else
                        clk_fp                      <= 0;
                           
                end else begin
                
                    if(!flanco) begin
                        if(cntr_flankn == (divider / 4) - 1) begin                 
                            clk_fn                  <= 1; 
                            cntr_flankn             <= 0;
                            flanco                  <= 1;         
                        end else begin
                            clk_fn                  <= 0;
                            cntr_flankn             <= cntr_flankn + 1;        
                        end  
                    end else
                        clk_fn                      <= 0;
                         
                end     
            
            end else begin
            
                counter         <= 0;
                clk_out         <= 1;  
                cntr_flankp     <= 0;
                cntr_flankn     <= 0;                
            
            end
        
        end
        
    //salidas
    always_comb begin
        clk_fp_o    = clk_fp;
        clk_fn_o    = clk_fn;
        clk_sck_o   = clk_out;
    end
    
endmodule

module WCLK(
    input   logic                   CLK_100MHZ,
    output  logic                   CLK_10MHZ,
    output  logic                   locked
    );
    
    // Variables internas
    logic                           wclk;
    logic                           clk_fn;
    
    // Asignaciones
    assign clk_fn                   = CLK_100MHZ;
    
    always @(posedge CLK_100MHZ) begin
        if (!locked) begin
            wclk <= 0;
        end else begin
            if (clk_fn) begin
                wclk <= ~wclk;
            end
        end
    end
    
    // Salida
    assign CLK_10MHZ = wclk;
    
endmodule

module module_seg7_control #(parameter time PERIODO = 1e-3)(
    input   logic               clk_10Mhz_i,
    input   logic               reset_i,
    input   logic   [31 : 0]    display_i,
    output  logic   [6 : 0]     display_o,
    output  logic   [7 : 0]     display_select_o
);

    // Definir los registros para almacenar los valores del display y la selección
    logic [31 : 0] display_reg;
    logic [2 : 0]  digit_select_reg;
    
    // Definir los contadores para el multiplexado del display
    logic [23 : 0] display_counter;
    logic [2 : 0]  select_counter;
    
    always_ff @(posedge clk_10Mhz_i or posedge reset_i) begin
        if (reset_i) begin
            // Reset
            display_reg <= 0;
            digit_select_reg <= 0;
            display_counter <= 0;
            select_counter <= 0;
        end else begin
            // Actualizar el valor del display y la selección cada PERIODO de tiempo
            if (display_counter == (PERIODO * 10_000_000) - 1) begin
                display_reg <= display_i;
                digit_select_reg <= digit_select_reg + 1;
            end
            
            // Incrementar los contadores
            display_counter <= display_counter + 1;
            if (display_counter == (PERIODO * 10_000_000) - 1) begin
                display_counter <= 0;
                select_counter <= select_counter + 1;
            end
        end
    end
    
    // Lógica combinacional para el multiplexado del display y la selección
    always_comb begin
        // Selección del dígito del display
        case (digit_select_reg)
            0: display_select_o = 8'b111_1110; // Digito 0
            1: display_select_o = 8'b111_1101; // Digito 1
            2: display_select_o = 8'b111_1011; // Digito 2
            3: display_select_o = 8'b111_0111; // Digito 3
            4: display_select_o = 8'b110_1111; // Digito 4
            5: display_select_o = 8'b101_1111; // Digito 5
            6: display_select_o = 8'b011_1111; // Digito 6
            7: display_select_o = 8'b111_1111; // Digito 7 (Apagado)
            default: display_select_o = 8'b111_1111; // Valor por defecto (Apagado)
        endcase
        
        // Valor del display actual basado en el dígito seleccionado
        case (digit_select_reg)
            0: display_o = display_reg[3:0];
            1: display_o = display_reg[7:4];
            2: display_o = display_reg[11:8];
            3: display_o = display_reg[15:12];
            4: display_o = display_reg[19:16];
            5: display_o = display_reg[23:20];
            6: display_o = display_reg[27:24];
            7: display_o = display_reg[31:28];
            //6: display_o = display_reg[27: display_o = display_reg[31:28];
            default: display_o = 7'b0000000; // Valor por defecto (display apagado)
        endcase
    end
    
endmodule
